#pragma once

#include <iostream>
#include <atomic>

#include "AutofocusDLL.hpp"
#include "HawkeyeConfig.hpp"
#include "LedBase.hpp"


// used for passing to the focus motor stepping methods
#define DIR_STEP_UP	true
#define	DIR_STEP_DN	false


class CameraAutofocus
{
public:
	typedef struct cameraAutofocusParams
	{
		HawkeyeConfig::LedType ledType;
		uint32_t exposureTime_usec;
		std::shared_ptr<boost::asio::io_context> pInternalIos;
		std::shared_ptr<boost::asio::io_context> pUpstreamIos;
	}CAFParams;

	CameraAutofocus(CAFParams params);
	~CameraAutofocus();

	void execute(std::function<void(bool)> onCompleteCallback);
	void cancelExecute();
	bool isBusy() const;

	std::shared_ptr<AutofocusResultsDLL> getResult() const;
	void reset();

private:
	typedef struct
	{
		double sharpness;
		int32_t position;
		uint32_t filenum;
	} SharpnessData_t;

	typedef struct
	{
		int32_t start;
		int32_t end;
	} FocusRange_t;

	enum class ExecuteInternalSteps : uint8_t
	{
		eEntryPoint = 0,
		eFocusHome,
		eFocusStartPos,
		eCoarseFocus,
		eFineFocus,
		eGetFocusImage,
		eFocusOffset,
		eComplete,
		eError,
	};

	enum class CoarseFocusSteps : uint8_t
	{
		eEntryPoint = 0,
		eFocusStep,
		eTakePicture,
		eCheckComplete,
		eComplete,
		eError
	};

	enum class FineFocusSteps : uint8_t
	{
		eEntryPoint = 0,
		eFocusStep,
		eTakePicture,
		eCheckComplete,
		eComplete,
		eError
	};

	void executeInternal(
		ExecuteInternalSteps currentStep, std::function<void(bool)> callback);

	void coarseFocus(
		CoarseFocusSteps currentStep, std::function<void(bool)> callback);

	void fineFocus(
		FineFocusSteps currentStep, FocusRange_t focusRange, std::function<void(bool)> callback);
	
	void takePictureAndUpdateFgMask(bool coarse_focus, std::function<void(bool)> callback);

	static bool getHistogramWhiteCount(cv::Mat& image, int32_t* whiteCount);
	static boost::optional<CameraAutofocus::SharpnessData_t> findMaxSharpness(const std::vector<SharpnessData_t>& sharpnessData);
	static bool saveAutofocusImage (cv::Mat& image, const std::string& imagePath);

	std::unique_ptr<AutofocusResultsDLL> generateResult(
		bool success, const SharpnessData_t& maxFocusData, const std::vector<SharpnessData_t>& vSharpnessData);

	std::atomic_bool isBusy_;
	std::atomic_bool isCancelled_;
	CAFParams params_;
	std::shared_ptr<AutofocusResultsDLL> result_;

	cv::Mat fgMaskMOG_; // fg mask generated by MOG method
	std::unique_ptr<cv::BackgroundSubtractorMOG> pMOG_; // MOG Background subtractor
	uint32_t imageCnt_;
	std::vector<SharpnessData_t> sharpnessData_;
	SharpnessData_t maxFocusData_;
	cv::Mat finalFocusedImage_;
};
